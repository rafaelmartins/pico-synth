#!/usr/bin/env python3

import itertools
import math
import os

cpu_frequency = 133000000
cpu_cycles_per_sample = 34

waveform_amplitude = 0x7ff
waveform_samples_per_cycle = 0x2000

a4_midi_number = 69
a4_frequency = 440.0

audio_sample_rate = 44100

waveforms = {
    'sine': [math.sin(2 * math.pi * i / waveform_samples_per_cycle)
             for i in range(waveform_samples_per_cycle)],
    'sawtooth': [-1 + 2 * ((i / waveform_samples_per_cycle) % 1)
                 for i in range(waveform_samples_per_cycle)],
    'triangle': [2 / math.pi * math.asin(math.sin(2 * math.pi * i / waveform_samples_per_cycle))
                 for i in range(waveform_samples_per_cycle)],
    'square': [1 - 2 * math.floor(2 * i / waveform_samples_per_cycle)
               for i in range(waveform_samples_per_cycle)],
}
for k in waveforms:
    waveforms[k] = [i * waveform_amplitude for i in waveforms[k]]

note_prefixes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']
note_frequencies = [a4_frequency * 2 ** ((i - a4_midi_number) / 12)
                    for i in range(128)]


def format_hex(v, zero_padding=4):
    return '%s0x%0*x' % (int(v) < 0 and '-' or '', zero_padding, abs(int(v)))


def header():
    yield '// this file was generated by generate.py. do not edit!'
    yield ''
    yield '#pragma once'


def dump_headers(headers, system=True):
    if headers:
        yield ''

    for header in headers:
        yield '#include %s%s%s' % (system and '<' or '"', header, system and '>' or '"')


def dump_macros(items):
    if items:
        yield ''

    for item in items:
        yield '#define %s %s' % (item, items[item])


def dump_data_vars(items, suffix=''):
    for var, value in items.items():
        yield ''
        yield 'static const int16_t %s%s[] = {' % (var, suffix)
        for i in range(0, len(value) // 8):
            yield '    %s,' % ', '.join([format_hex(j)
                                         for j in value[i * 8: (i + 1) * 8]])
        yield '};'


def dump_notes():
    yield ''
    yield 'static const ps_engine_note_t notes[] = {'

    for i, f in enumerate(note_frequencies):
        step = waveform_samples_per_cycle / (audio_sample_rate / f)
        yield '    {'
        yield '        .id   = %d,' % i
        yield '        .name = "%s%d",' % (note_prefixes[i % 12], (i // 12) - 1)
        yield '        .step = {'
        yield '            .pint  = %s,' % format_hex(step)
        yield '            .pfrac = %s,' % format_hex((step - float(int(step))) * (1 << 16))
        yield '        },'
        yield '    },'

    yield '};'


generators = {
    os.path.join('engine', 'driver-mcp4822-data.h'): itertools.chain(
        dump_macros({
            'mcp4822_clkdiv': cpu_frequency / (audio_sample_rate * cpu_cycles_per_sample),
        }),
    ),
    os.path.join('engine', 'note-data.h'): itertools.chain(
        dump_headers(['pico-synth/engine.h']),
        dump_macros({
            'notes_last': len(note_frequencies) - 1,
        }),
        dump_notes(),
    ),
    os.path.join('engine', 'module-oscillator-data.h'): itertools.chain(
        dump_macros({
            'waveform_samples_per_cycle': format_hex(waveform_samples_per_cycle),
        }),
        dump_data_vars(waveforms, '_table'),
    ),
}


if __name__ == '__main__':
    rootdir = os.path.dirname(os.path.abspath(__file__))
    for key in generators:
        print('generating %s ...' % key)

        with open(os.path.join(rootdir, key), 'w') as fp:
            for l in itertools.chain(header(), generators[key]):
                print(l, file=fp)
